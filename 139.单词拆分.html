<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
    </head>
    <body>
        <script async defer>
            /**
            给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
            说明：
            拆分时可以重复使用字典中的单词。
            你可以假设字典中没有重复的单词。
            示例 1：
            输入: s = "leetcode", wordDict = ["leet", "code"]
            输出: true
            解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"

            链接：https://leetcode-cn.com/problems/word-break

            */
            // 思路 还是用到了动态规划 拆分成小问题来解决
            //  对于问题(s, wordDict) 我们是否可以用(s', wordDict) 来解决。
            /**
            * @param {string} s
            * @param {string[]} wordDict
            * @return {boolean}
            */
            var wordBreak = function(s, wordDict) {
                // 创建一个空数组 
                const dp = Array(s.length + 1)
                dp[0] = true
                for (let i = 0; i < s.length+1; i++) {
                    for (let item of wordDict) {
                        if (dp[i - item.length] && item.length <= i) {
                            if (s.substring(i - item.length, i) === item) {
                                dp[i] = true
                            }
                        }
                    }
                }
                return dp[s.length] || false
            };
        </script>
    </body>
</html>